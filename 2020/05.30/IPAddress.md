# IPv4 address

IP 주소는 32bit address다. IP주소는 유일하며, 2진수 표현으로 했을 때 32bit로 표현하고, `.`와 10진수 표기법으로 하면 우리가 흔히 보는 `xxx.xxx.xxx.xxx` 형식으로 표현할 수 있다.

32비트 IPv4 주소는 계층적이지만, 두 부분으로 나눌 수 있다.

1. 첫 부분은 prefix라고 부르고, network를 정의 한다.
2. 두번째 부분은 suffix라고 부르고, node connection를 정의한다. (Host IP)

![IPv4](/2020/assets/img/ipv4.png)

## Classful addressing

IP 주소 공간은 5개의 클래스로 나누어진다.(A, B, C, D, E)

![classful address](/2020/assets/img/classful_address.png)

Class | Prefixes | First byte
--- | --- | ---
A | n = 8 bits | 0 ~ 127
B | n = 16 bits | 128 ~ 191
C | n = 24 bits | 192 ~ 223
D | X | 224 ~ 239
E | X | 240 ~ 255

![ipv4 class](/2020/assets/img/ipv4_class.png)

이런 주소들은 빠르게 소진되었고, 인터넷에 연결하려고 하는 개인이나 조직을 위해 더이상 가용한 주소가 없다.

- Class A는 16,777,216개의 IP를 갖는다. 이 규모의 조직은 소수 밖에 없어서 대부분의 주소는 낭비됨
- Class B는 중간 사이즈의 기업을 위해 디자인되었으나, 많은 주소들이 사용하지 않는 상태로 남아있다.
- Class C는 256개의 IP밖에 없다. 이 주소들을 사용하는 회사들은 너무 적어서 불편함.
- Class E는 거의 사용되지 않았다. 전체 클래스가 낭비되고 있음. (미래를 위해 남겨두긴 했지만..)

## 서브넷, 슈퍼넷

주소고갈을 완화하기 위해서 Subnetting, Supernetting이 권장되었다.

- Subnetting에서 Class A나 Class B는 몇개의 subnet으로 나누어진다. 각 서브넷들은 원래 네트워크보다 더 긴 prefix를 갖는다. 즉, 큰 블록을 더 작은 블록으로 나눈다.
    1. 대부분의 큰 조직들이 자신들이 사용하지 않는 블록을 더 작은 조직을 위해 나누어주는 것을 좋아하지 않았기 때문에 효과적이지 않았다.
- Supernetting에서는 여러 Class C 블록들을 모아서 더 큰 블록으로 결합해서 사용한다. 256개보다 많은 아이피를 필요로 하는 조직에 적합했다.
    1. 이 아이디어는 패킷 라우팅을 더 어렵게 만들어서 효과적이지 않았다.

## Classless addressing

Classless addressing에서는 클래스에 속하지 않는 가변길이 블록이 사용되었다. 1, 2, 4, 128 주소 등의 블록을 가질수 있다.

주소의 prefix는 network를 정의한다. suffix는 node(device)를 정의한다. 그러므로 2^0, 2^1, ..., 2^32 주소의 블럭을 가질 수 있다. (작은 prefix는 큰 네트워크, 큰 prefix는 작은 네트워크를 의미한다. - 내부 node의 개수가 많은 것이니까)

### 제한

1. 블록 내의 주소 수
    - 2의 승수개, 2^0, 2^1 ...
2. 첫 주소
    - 첫 번째 주소는 주소의 개수로 균등하게 나눌 수 있어야한다
3. Mask
    - 주소는 반드시 mask를 가져야한다.
    - 마스크는 classless 도메인 간 라우팅 또는 CIDR 표기법으로 주어진다. Classless 주소의 포맷은 `X.Y.Z.t/n` 형식이고, 슬래시 다음의 n은 블록의 모든 주소에서 동일한 비트 수를 정의한다.

### Mask

- Prefix는 주소 범위의 공통 부분의 또다른 이름이다. classful 주소 지정 방식에서 netid와 비슷하다.
- Prefix 길이는 CIDR 표기법에서의 n
- Classful 주소지정 방식은 classless 주소지정 방식의 특별한 케이스다.
- Suffix는 hostid와 비슷하다.
- Suffix 길이는 CIDR 표기법에서 suffix(32-n)의 길이다.

/n | Mask
--- | ---
/1 | 128.0.0.0
/2 | 192.0.0.0
/3 | 224.0.0.0
... | ...
/31 | 255.255.255.254
/32 | 255.255.255.255

### Mask - 예시

classless 주소 167.199.170.82/27 이 있다. 여기서 알 수 있는 것은 무엇일까?

1. 이 네트워크 주소의 개수는 2^(32-27) = 2^5 = 32개다
2. 이 네트워크의 첫 주소는 앞의 27비트는 고정, 뒤의 5비트는 0인 값이다.
    - 3번째 . 까지가 24비트고 네번째 숫자인 82는 bit로 바꾸면 **010**10010 이므로, 여기서 앞에 표기한 010까지만 고정, 뒤의 숫자는 모두 0인 01000000 = 64 이다.
    - 167.199.170.64/27
3. 이 네트워크의 마지막 주소는 앞의 27비트는 고정, 뒤의 5비트는 1인 값이다.
    - 위에서 계산한 방식대로 **010**11111 이므로, 이는 95 이다.
    - 167.199.170.95/27

위에서 계산한 것을 NOT, AND, OR을 이용해서 구할 수도 있다. (/27은 255.255.255.224이다)

1. 네트워크 주소 개수: NOT(mask) + 1 = 0.0.0.31 + 1 = 32개
2. 첫 주소: address AND mask = 167.199.170.82 AND 255.255.255.224 = 167.199.170.64/27
3. 마지막 주소: address OR (NOT mask) = 167.199.170.95/27

### 예시 2

classless 주소지정 방식에서 특정 주소는 한 주소 블록에만 속한 것이 아니다. 예를 들어 주소 230.8.24.56은 많은 블록에 속할 수 있다. 아래처럼..

prefix length | block
--- | ---
16 | 230.8.0.0 ~ 230.8.255.255
20 | 230.8.16.0 ~ 230.8.31.255
26 | 230.8.24.0 ~ 230.8.24.63
28 | 230.8.24.48 ~ 230.8.24.63
29 | 230.8.24.56 ~ 230.8.24.63
31 | 230.8.24.56 ~ 230.8.24.57

## Network Address

주소 블럭의 첫 주소인 network address는 목적지 네트워크의 패킷을 라우팅하는데 사용되기 때문에 특히 중요하다.

첫 주소 = `(10진수 prefix) * 2^(32-n) = (10진수 prefix) * N`

### Network Address - 예시

어떤 조직이 14.24.74.0/24로 시작하는 주소 블럭을 할당 받았다. 해당 조직은 3개의 서브 주소 블럭을 가져야하고, 그래서 세개의 서브넷에 사용할 3개의 서브블록이 필요하다. 만약 서브블록을 30, 40, 120개로 할당해야 한다고 하면 이 서브블록들을 디자인 해보자.

1. 이 블록에는 2^(32-24) = 2^8 = 256 개의 주소가 있다.
2. 첫 주소는 14.24.74.0/24
3. 마지막 주소는 14.24.74.255/24

이 256개의 주소들을 할당하기 위해 일단 가장 큰 120개부터 할당한다.

1. 120개를 할당하기 위해서는 128개(2의 승수)를 할당한다.
2. subnet mask는 n = 25
3. 첫 주소는 14.24.74.0/25, 마지막 주소는 14.24.74.127/25

그 다음 40개를 할당해보자

1. 40개를 할당하기 위해서는 64개(2의 승수)를 할당
2. subnet mask는 n = 26
3. 첫 주소는 14.24.74.128/26, 마지막 주소는 14.24.74.191/26

그 다음 30개를 할당

1. 30개를 할당하기 위해서는 32개를 할당
2. subnet mask는 n = 27
3. 첫 주소는 14.24.74.192/27, 마지막 주소는 14.24.74.223/27

이렇게 할당한다면, 128 + 64 + 32 = 224개의 주소를 할당 했다. 그래서 나머지 32개의 주소가 남는다.
